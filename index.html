<!DOCTYPE html>
<html>
<head>
    <title>WEonG - Newfoundland Snapping Route</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body, html, #map { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; }
        .weather-popup { font-family: sans-serif; line-height: 1.4; }
        .critical { color: #d9534f; font-weight: bold; }
    </style>
</head>
<body>
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script type="module">
        // We use your locked-in Bulletin logic for the popups
        import { BulletinLogic } from './engine/weather-bulletin.js';

        let map, communities = [];
        let originMarker, destMarker, routeLine;

        async function init() {
            map = L.map('map').setView([48.5, -55.8], 7);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

            // Load the deep-dive Newfoundland dataset [2025-12-26]
            const response = await fetch('data/nl/communities.json');
            const data = await response.json();
            communities = data.features;

            // Define Default Points (Corner Brook & St. John's)
            const startNode = communities.find(c => c.properties.name === "Corner Brook");
            const endNode = communities.find(c => c.properties.name === "St. John's");

            // Create Draggable Pins with Snapping Logic
            originMarker = createDraggablePin(startNode, "Origin");
            destMarker = createDraggablePin(endNode, "Destination");

            drawRoute();
        }

        function createDraggablePin(feature, label) {
            const coords = [feature.geometry.coordinates[1], feature.geometry.coordinates[0]];
            const marker = L.marker(coords, { draggable: true }).addTo(map);
            
            updatePopup(marker, feature.properties, label);

            marker.on('dragend', function() {
                const snapped = findNearestCommunity(marker.getLatLng());
                marker.setLatLng([snapped.geometry.coordinates[1], snapped.geometry.coordinates[0]]);
                updatePopup(marker, snapped.properties, label);
                drawRoute();
            });

            return marker;
        }

        function findNearestCommunity(latlng) {
            return communities.reduce((prev, curr) => {
                const prevDist = latlng.distanceTo([prev.geometry.coordinates[1], prev.geometry.coordinates[0]]);
                const currDist = latlng.distanceTo([curr.geometry.coordinates[1], curr.geometry.coordinates[0]]);
                return currDist < prevDist ? curr : prev;
            });
        }

        function updatePopup(marker, props, label) {
            // Rule: Nearest 10% POP, Omit < 30%, Level 3 Exception Trigger
            const mockWeather = { pop: 50, uvIndex: 6, isDaytime: true, levels: { wind: 3 } };
            const report = BulletinLogic.generate(props, mockWeather);

            marker.bindPopup(`
                <div class="weather-popup">
                    <b>${label}: ${report.location}</b><br>
                    POP: ${report.pop || '---'}<br>
                    UV Index: ${report.uvIndex || '---'}<br>
                    ${report.isCritical ? '<span class="critical">⚠️ LEVEL 3 PRIORITY</span>' : ''}
                </div>
            `).openPopup();
        }

        function drawRoute() {
            if (routeLine) map.removeLayer(routeLine);
            routeLine = L.polyline([originMarker.getLatLng(), destMarker.getLatLng()], {
                color: '#0047AB', weight: 5, opacity: 0.7, dashArray: '10, 10'
            }).addTo(map);
        }

        init();
    </script>
</body>
</html>
