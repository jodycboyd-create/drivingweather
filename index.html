<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WEonG - Stability Anchor [Locked]</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
    <style>
        body, html, #map { margin: 0; padding: 0; height: 100%; width: 100%; background: #001220; }
        
        /* Glassmorphism Panel [cite: 2025-12-27] */
        .ui-panel {
            position: absolute; bottom: 30px; left: 30px; z-index: 1000;
            background: rgba(0, 18, 32, 0.85); backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1); padding: 20px;
            border-radius: 16px; color: white; font-family: sans-serif;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6); width: 240px;
        }

        .eta-flag {
            background: #0047AB; color: white; padding: 4px 10px;
            border-radius: 20px; font-weight: bold; font-size: 12px;
            border: 2px solid white; white-space: nowrap;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3); text-align: center;
        }

        .snapping-label {
            font-weight: bold; color: #0047AB; background: white;
            border: 2px solid #0047AB; padding: 6px 12px; border-radius: 8px;
            pointer-events: none; white-space: nowrap;
        }
        .leaflet-routing-container { display: none !important; }
        .ctrl-btn { background: rgba(255, 255, 255, 0.1); border: none; color: white; width: 34px; height: 34px; cursor: pointer; border-radius: 6px; font-size: 18px; }
        .ctrl-btn:hover { background: #0047AB; }
    </style>
</head>
<body>

<div class="ui-panel">
    <div style="font-size: 10px; color: #00B4DB; letter-spacing: 1.5px;">DRIVE VELOCITY</div>
    <div style="display: flex; justify-content: space-between; align-items: center; margin: 12px 0;">
        <span style="font-size: 28px;"><span id="speedDisplay">100</span> <small style="font-size: 14px; color: #888;">km/h</small></span>
        <div style="display: flex; gap: 8px;">
            <button class="ctrl-btn" onclick="adjustSpeed(-5)">âˆ’</button>
            <button class="ctrl-btn" onclick="adjustSpeed(5)">+</button>
        </div>
    </div>
    <div style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 12px; font-size: 13px; color: #ccc;">
        Distance: <span id="distVal" style="color: white; font-weight: bold;">0</span> km<br>
        Travel Time: <span id="timeVal" style="color: white; font-weight: bold;">0</span>
    </div>
</div>

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>

<script>
    /**
     * [weong-route] - Resilience Build
     * Fixes "Black Screen" by ensuring data loads before marker initialization. [cite: 2025-12-27]
     */
    let map, communities = [], markers = [null, null], routingControl;
    let etaMarker = null; 
    let driveSpeed = 100;
    let currentDistanceKm = 0;

    async function init() {
        // 1. Initialize Map first [cite: 2025-12-26]
        map = L.map('map').setView([49.5, -56.0], 5); 
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

        try {
            // 2. Await Data strictly [cite: 2025-12-26]
            const response = await fetch('data/nl/communities.json');
            const data = await response.json();
            communities = data.features;
            
            // 3. Only setup markers AFTER data exists
            if (communities.length > 0) {
                setupMarkers();
            }
        } catch (e) { 
            console.error("Critical: Dataset failed to load."); 
        }
    }

    function adjustSpeed(delta) {
        driveSpeed = Math.max(30, Math.min(130, driveSpeed + delta));
        document.getElementById('speedDisplay').innerText = driveSpeed;
        updateETA();
    }

    function findNearestLandNode(latlng) {
        return communities.reduce((prev, curr) => {
            const p = L.latLng(prev.geometry.coordinates[1], prev.geometry.coordinates[0]);
            const c = L.latLng(curr.geometry.coordinates[1], curr.geometry.coordinates[0]);
            return latlng.distanceTo(c) < latlng.distanceTo(p) ? curr : prev;
        });
    }

    function setupMarkers() {
        const anchors = [[48.9515, -57.9485], [47.5615, -52.7126]]; [cite: 2025-12-26]
        
        anchors.forEach((coord, i) => {
            const town = findNearestLandNode(L.latLng(coord));
            const pos = [town.geometry.coordinates[1], town.geometry.coordinates[0]];
            
            const marker = L.marker(pos, { draggable: true }).addTo(map);
            marker.bindTooltip(town.properties.name, { 
                permanent: true, direction: 'top', className: 'snapping-label' 
            }).openTooltip();
            
            markers[i] = marker;

            marker.on('drag', (e) => {
                const liveTown = findNearestLandNode(e.latlng);
                marker.setTooltipContent(liveTown.properties.name);
            });

            marker.on('dragend', () => {
                const finalTown = findNearestLandNode(marker.getLatLng());
                marker.setLatLng([finalTown.geometry.coordinates[1], finalTown.geometry.coordinates[0]]); 
                syncHighway();
            });
        });
        syncHighway();
    }

    function syncHighway() {
        if (!markers[0] || !markers[1]) return;

        const wps = [markers[0].getLatLng(), markers[1].getLatLng()];
        if (routingControl) {
            routingControl.setWaypoints(wps);
        } else {
            routingControl = L.Routing.control({
                waypoints: wps, createMarker: () => null, addWaypoints: false,
                lineOptions: { styles: [{ color: '#0047AB', weight: 8, opacity: 0.8 }] }
            }).addTo(map);

            routingControl.on('routesfound', function(e) {
                const route = e.routes[0];
                currentDistanceKm = (route.summary.totalDistance / 1000).toFixed(1);
                document.getElementById('distVal').innerText = currentDistanceKm;
                
                // MID-POINT LOGIC [cite: 2025-12-27]
                const midIndex = Math.floor(route.coordinates.length / 2);
                const midCoord = route.coordinates[midIndex];
                
                if (etaMarker) {
                    etaMarker.setLatLng(midCoord);
                } else {
                    etaMarker = L.marker(midCoord, {
                        icon: L.divIcon({ 
                            className: 'eta-flag', 
                            html: '<div id="flagTime"></div>' 
                        })
                    }).addTo(map);
                }

                updateETA();
                map.flyToBounds(L.latLngBounds(route.coordinates), { padding: [80, 80], duration: 1.5 });
            });
        }
    }

    function updateETA() {
        if (currentDistanceKm === 0) return;
        const hours = currentDistanceKm / driveSpeed;
        const h = Math.floor(hours);
        const m = Math.round((hours - h) * 60);
        const timeStr = `${h}h ${m}m`;
        
        document.getElementById('timeVal').innerText = timeStr;
        const flag = document.getElementById('flagTime');
        if (flag) flag.innerText = timeStr;
    }

    window.onload = init;
</script>
</body>
</html>
