<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WEonG - Velocity Calibrated [LOCKED]</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
    <style>
        body, html, #map { margin: 0; padding: 0; height: 100%; width: 100%; background: #f0f0f0; }
        .snapping-label {
            font-weight: bold; color: #0047AB; background: white;
            border: 2px solid #0047AB; padding: 4px 10px; border-radius: 8px;
            pointer-events: none; white-space: nowrap; box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            font-family: sans-serif; font-size: 12px;
        }
        .leaflet-routing-container { display: none !important; }
        .eta-capsule {
            background: rgba(26, 115, 232, 0.95); backdrop-filter: blur(4px);
            color: white; padding: 6px 16px; border-radius: 20px;
            border: 1px solid white; box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            font-family: sans-serif; display: flex; gap: 10px;
            align-items: center; white-space: nowrap; font-size: 14px; font-weight: 700;
        }
        #velocity-widget {
            position: absolute; bottom: 30px; right: 20px; z-index: 1000;
            background: #1a1a1a; color: #00ff00; padding: 15px; border-radius: 10px;
            font-family: 'Courier New', monospace; box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border: 1px solid #333; min-width: 130px; text-align: center;
        }
        .v-label { font-size: 10px; color: #888; text-transform: uppercase; margin-bottom: 5px; }
        .v-value { font-size: 24px; font-weight: bold; }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div id="velocity-widget">
        <div class="v-label">Est. Cruising Speed</div>
        <div class="v-value"><span id="speed-val">0</span> <small>km/h</small></div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>

    <script>
        /**
         * [weong-route] - ANCHOR RESTORATION 2025.12.27
         * Calibration: Adjusted velocity to reflect TCH 100km/h standards.
         */
        let map, communities = [], markers = [null, null], routingControl, etaMarker = null;

        async function init() {
            map = L.map('map', { zoomControl: false }).setView([48.8, -55.5], 7);
            L.tileLayer('http://{s}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', {
                maxZoom: 20, subdomains: ['mt0', 'mt1', 'mt2', 'mt3']
            }).addTo(map);

            try {
                const res = await fetch('data/nl/communities.json');
                const data = await res.json();
                communities = data.features;
                if (communities.length > 0) setupApp();
            } catch (e) { console.error("Data Load Error"); }
        }

        function findNearest(latlng) {
            return communities.reduce((prev, curr) => {
                const p = L.latLng(prev.geometry.coordinates[1], prev.geometry.coordinates[0]);
                const c = L.latLng(curr.geometry.coordinates[1], curr.geometry.coordinates[0]);
                return latlng.distanceTo(c) < latlng.distanceTo(p) ? curr : prev;
            });
        }

        function setupApp() {
            const starts = [[48.95, -57.95], [47.56, -52.71]];
            starts.forEach((c, i) => {
                const node = findNearest(L.latLng(c));
                const m = L.marker([node.geometry.coordinates[1], node.geometry.coordinates[0]], { draggable: true }).addTo(map);
                m.bindTooltip(node.properties.name, { permanent: true, className: 'snapping-label', direction: 'top', sticky: true, offset: [0, -10] }).openTooltip();
                markers[i] = m;
                
                m.on('drag', () => m.getTooltip().setContent(findNearest(m.getLatLng()).properties.name));
                m.on('dragend', () => {
                    const final = findNearest(m.getLatLng());
                    m.setLatLng([final.geometry.coordinates[1], final.geometry.coordinates[0]]);
                    m.getTooltip().setContent(final.properties.name);
                    syncRoute();
                });
            });

            routingControl = L.Routing.control({
                router: L.Routing.osrmv1({ serviceUrl: 'https://router.project-osrm.org/route/v1' }),
                waypoints: [markers[0].getLatLng(), markers[1].getLatLng()],
                createMarker: () => null,
                addWaypoints: false,
                routeWhileDragging: false,
                show: false,
                lineOptions: { styles: [{ color: '#1A73E8', weight: 8, opacity: 0.9 }] }
            }).addTo(map);

            routingControl.on('routesfound', (e) => {
                updateCapsule(e.routes[0]);
                calculateVelocity(e.routes[0]);
            });

            syncRoute();
        }

        function calculateVelocity(route) {
            const distKm = route.summary.totalDistance / 1000;
            const timeHr = route.summary.totalTime / 3600;
            
            // CALIBRATION LOGIC [cite: 2025-12-27]
            // If the distance is significant (TCH travel), we normalize to 100km/h.
            // If shorter branch travel, we allow the calculated average.
            let velocity = Math.round(distKm / timeHr);
            
            if (distKm > 50) { 
                // Normalize major routes to 100km/h TCH standard
                velocity = 100; 
            } else {
                // Apply a 1.15x modifier to short routes to account for 
                // routing engine over-caution on branches [cite: 2025-12-27]
                velocity = Math.min(Math.round(velocity * 1.15), 90);
            }
            
            document.getElementById('speed-val').innerText = velocity;
        }

        function updateCapsule(route) {
            const mid = route.coordinates[Math.floor(route.coordinates.length / 2)];
            const duration = Math.round(route.summary.totalTime / 60);
            const h = Math.floor(duration / 60), m = duration % 60;
            const dist = (route.summary.totalDistance / 1000).toFixed(1);
            
            const html = `<div class="eta-capsule">${h}h ${m}m | ${dist} km</div>`;
            if (!etaMarker) {
                etaMarker = L.marker(mid, { icon: L.divIcon({ className: '', html: html, iconSize: [160, 40], iconAnchor: [80, 20] }) }).addTo(map);
            } else {
                etaMarker.setLatLng(mid).setIcon(L.divIcon({ className: '', html: html, iconSize: [160, 40], iconAnchor: [80, 20] }));
            }
        }

        function syncRoute() {
            if (routingControl) routingControl.setWaypoints([markers[0].getLatLng(), markers[1].getLatLng()]);
        }
        window.onload = init;
    </script>
</body>
</html>
